---
title: "Experimenting and Implementing a new AQLI backend workflow"
author: "Aarsh"
date: '2022-10-18'
output: html_document
---

# setup
```{r}
# load libraries
library(raster)
library(rgdal)
library(dplyr)
library(ncdf4)
library(assertthat)
library(fasterize)
library(sf)
library(SpaDES)
library(foster) # for matching resolution of 2 different rasters
library(DBI) # for connecting R with Postgres
library(RPostgres)
library(ggplot2)
library(RPostgres)
library(sparklyr)
library(data.table)

# global variables (check for updates, if any)
who_pm2.5_standard <- 5 # in micrograms per cubic meter, annual average PM2.5 standard
aqli_lyl_constant <- 0.098
india_pm2.5_standard <- 40 # in micrograms per cubic meter
region_pm2.5_standard <- 15 # China

print("Libraries and Global variables loaded in.")

```

# load in raw master pollution and population datasets and making sure that their CRS are the same

```{r}
# load raw global pollution raster for AQLI 2021 (2023 release) dataset
pol_raw_0.01 <- raster::raster("./ar.2023.update.using.2021.pol.data/data/input/pollution/0.01x0.01/V5GL03.HybridPM25-NoDust-NoSeaSalt.Global.202101-202112.nc")

# load latest (2021, as on Novmeber, 2022) Landscan raw global population raster
pop_raw_landscan <- raster::raster("./ar.2023.update.using.2021.pol.data/data/input/population/landscan-global-2021.tif")

# load latest colormap shapefile for (last complete updated: November, 2022)
colormap <- st_read("./ar.2023.update.using.2021.pol.data/data/intermediate/1_population_and_colormap/1_shapefile_aggregate/colormap/colormap.shp")

# naming the raw global pollution data and setting its crs
crs(pol_raw_0.01) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
names(pol_raw_0.01) <- "pm2021"

# naming the raw global landscan population data and setting its crs to be the same as the pollution data
crs(pop_raw_landscan) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
names(pop_raw_landscan) <- "landscan2021"

print("raw data files read in")
```




# create a raster based population weighted pollution map for LA in the colors similar to how plume labs map
```{r}

# crop colormap to the extent of Los Angeles
colormap_la <- colormap %>%
   filter(NAME_2 %in% "Los Angeles")

# cropping pollution 0.01 data to the extent of LA
pol_raw_0.01_la <- raster::crop(pol_raw_0.01, colormap_la)

# cropping landscan 0.008333 res data to the extent of LA
pop_raw_landscan_la <- raster::crop(pop_raw_landscan, colormap_la)

# matching the resolution of the cropped population and pollution datasets
pol_0.01_in_landscan_pop_res <- foster::matchResolution(pol_raw_0.01_la, pop_raw_landscan_la)

names(pol_0.01_in_landscan_pop_res) <- "pol_raw_raster_data"

pol_0.01_in_landscan_pop_res_df <- raster:as.data.frame(pol_0.01_in_landscan_pop_res)

la_values_hist_df <- data.frame(pol_la = values(pol_0.01_in_landscan_pop_res))

la_values_hist_plot <- la_values_hist_df %>%
  ggplot() +
  geom_histogram(mapping = aes(x = pol_la), color = "white", fill = "cornflowerblue") +
  labs(x = "PM2.5 pollution (in µg/m³)",  y = "Count", title = "Distribution of PM2.5 pollution across LA", 
       subtitle = "AQLI 2021 pollution data at 0.01 deg lat x 0.01 deg lon resolution") +
  scale_y_continuous(breaks = seq(0, 2000, 200)) +
  scale_x_continuous(breaks = seq(0, 20, 2)) +
  ggthemes::theme_hc()

# # creating a population weighted pollution average per pixel
# pop_weighted_pol_average_raster <- pol_0.01_in_landscan_pop_res * (pop_raw_landscan_la/sum(values(pop_raw_landscan_la), na.rm = TRUE))

# sanity checks on values in the above rasters
values_pop_weighted_pol <- values(pop_weighted_pol_average_raster)
values_pol_raw_0.01 <- values(pol_0.01_in_landscan_pop_res)
values_pop_raw <- values(pop_raw_landscan_la)

length(which(!is.na(values_pol_raw_0.01) & !is.na(values_pop_weighted_pol) & !is.na(values_pop_raw)))/length(which(!is.na(values_pol_raw_0.01)))

# writing and experimenting in QGIS
writeRaster(pop_weighted_pol_average_raster, "./qgis_experimentation/pop_weighted_pol_average_raster.tif")

# creating a life years lost layer
lyl_unweighted_pol_0.01 <- (values_pol_raw_0.01 - 5)*0.098
lyl_unweighted_pol_0.01 <- ifelse(lyl_unweighted_pol_0.01 < 0, 0, lyl_unweighted_pol_0.01)
lyl_unweighted_pol_0.01_months <- round(lyl_unweighted_pol_0.01 * 12, 1)

values(pol_raw_0.01_la) <- lyl_unweighted_pol_0.01_months

pol_raw_0.01_la_unweighted_lyl 

names(pol_raw_0.01_la) <- "lyl"

writeRaster(pol_raw_0.01_la, "./qgis_experimentation/pol_raw_0.01_unweighted_lyl_months.tif")


```

# Using the new workflow, generate county level population weighted pollution and life years lost numbers (WHO and National Standard) for India.

```{r}
# crop colormap to the extent of country
colormap_india <- colormap %>%
   filter(NAME_0 == "India")

# cropping pollution 0.01 data to the extent of the US
pol_raw_0.01_india <- raster::crop(pol_raw_0.01, colormap_india)

# cropping landscan 0.008333 res data to the extent of the US
pop_raw_landscan_india <- raster::crop(pop_raw_landscan, colormap_india)

# matching the resolution of the cropped population and pollution datasets
pol_0.01_india_in_landscan_pop_res <- foster::matchResolution(pol_raw_0.01_india, pop_raw_landscan_india)

# creating a life years lost to WHO layer for India
pol_values_india <- values(pol_raw_0.01_india)

# creating a raster brick using the population and pollution data for India.
india_raster_brick <- pop_raw_landscan_india %>% 
  addLayer(pol_0.01_india_in_landscan_pop_res) %>%
  addLayer(pol_0.01_india_in_landscan_pop_res) %>%
  addLayer(pol_0.01_india_in_landscan_pop_res)

# setting the names of the newly created placheoldes
names(india_raster_brick) <- c("population_2021", "pollution_2021", "lyl_who_standard", "lyl_nat_standard")

# generating values for layers containing lyl numbers relative to WHO standard
india_pollution_numbers <- values(india_raster_brick$pollution_2021)
india_lyl_numbers_who <- (india_pollution_numbers - who_pm2.5_standard)*aqli_lyl_constant
india_lyl_numbers_who <- ifelse(india_lyl_numbers_who < 0, 0, india_lyl_numbers_who)

# generating values for layers containing lyl numbes relative to the National standard
india_lyl_numbers_nat_standard <- (india_pollution_numbers - india_pm2.5_standard) * aqli_lyl_constant
india_lyl_numbers_nat_standard <- ifelse(india_lyl_numbers_nat_standard < 0, 0, india_lyl_numbers_nat_standard)

# updating the lyl layers with the above values
values(india_raster_brick$lyl_who_standard) <- india_lyl_numbers_who
values(india_raster_brick$lyl_nat_standard) <- india_lyl_numbers_nat_standard

# set the same crs for india pollution brick
crs(india_raster_brick) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

# Now match each population/pollution point to a colormap polygon. To do this, convert
# polygons to raster of same resolution as population raster, with value of each cell equal
# to objectid of polygon that covers its center.
# Fasterize is an ultra-fast version of the rasterize function.
print("Beginning to rasterize colormap shapefile")
polygon_cells <- fasterize(colormap_india, pol_0.01_india_in_landscan_pop_res, field = "objectid", fun = "last")
writeRaster(polygon_cells,
	filename = "./qgis_experimentation/colormap_india_rasterized.tif",
	format = "GTiff", overwrite = TRUE)

india_raster_brick <- india_raster_brick %>% addLayer(polygon_cells)

names(india_raster_brick)[length(names(india_raster_brick))] <- "colormap_objectid"

# convert to dataframe
india_raster_brick_df <- raster::as.data.frame(india_raster_brick)

# join with colormap (sans geometry)
india_raster_brick_df_joined_colormap <- india_raster_brick_df %>%
  left_join(colormap_india %>% st_drop_geometry(), by = c("colormap_objectid" = "objectid"))

# group by object id (which is gadm level 2) and create a population weighted average of pollution 

india_raster_brick_df_joined_colormap_summary <- india_raster_brick_df_joined_colormap %>%
  dplyr::group_by(colormap_objectid) %>%
  dplyr::mutate(pop_weights_gadm2  = population_2021/sum(population_2021, na.rm = TRUE),
                pm2021_pop_weighted = pollution_2021*pop_weights_gadm2) %>%
  dplyr::summarise(avg_pm2.5_2021 = sum(pm2021_pop_weighted, na.rm = TRUE)) %>%
  rename(objectid = colormap_objectid)

# join with colormap (with geometry)
india_raster_brick_df_joined_colormap_summary_geom <- india_raster_brick_df_joined_colormap_summary %>%
  left_join(colormap_india, by = "objectid")

# add lyl relative to WHO and National Standard column
india_raster_brick_df_joined_colormap_summary_geom <- india_raster_brick_df_joined_colormap_summary_geom %>%
  mutate(lyl_rel_who_2021 = (avg_pm2.5_2021 - who_pm2.5_standard) * aqli_lyl_constant, 
         lyl_rel_who_2021 = ifelse(lyl_rel_who_2021 < 0, 0, lyl_rel_who_2021), 
         lyl_rel_nat_stan_2021  = (avg_pm2.5_2021 - india_pm2.5_standard) * aqli_lyl_constant, 
         lyl_rel_nat_stan_2021 = ifelse(lyl_rel_nat_stan_2021 < 0, 0, lyl_rel_nat_stan_2021)) %>%
  select(objectid:NAME_2, lyl_rel_who_2021, lyl_rel_nat_stan_2021, everything()) 
  
india_raster_brick_df_joined_colormap_summary_geom <- st_as_sf(india_raster_brick_df_joined_colormap_summary_geom)
  
foo_plt <- india_raster_brick_df_joined_colormap_summary_geom %>%
  ggplot() +
  geom_sf(mapping = aes(fill = lyl_rel_who_2021)) + 
  scale_fill_viridis_b(breaks = c(0, 0.1, 0.5, 1, 2, 3, 4, 5, 6), option = "rocket", direction = -1)

foo <- india_raster_brick_df_joined_colormap_summary_geom %>%
  ggplot() +
  geom_sf(mapping = aes(fill = lyl_rel_who_2021)) + 
  scale_fill_viridis_b(breaks = c(0, 0.1, 0.5, 1, 2, 3, 4, 5, 6))


st_write(india_raster_brick_df_joined_colormap_summary_geom, "./qgis_experimentation/india_final_colormap_rasterized.shp")

```

# Using the new workflow, generate county level population weighted pollution and life years lost numbers (WHO and National Standard) for any general sub-global region


```{r}
# crop colormap to the extent of region
colormap_region <- colormap %>%
   filter(NAME_0 == "Cameroon")

# cropping pollution 0.01 data to the extent of the region
pol_raw_0.01_region <- raster::crop(pol_raw_0.01, colormap_region)

# cropping landscan 0.008333 res data to the extent of the region
pop_raw_landscan_region <- raster::crop(pop_raw_landscan, colormap_region)

# matching the resolution of the cropped population and pollution datasets
pol_0.01_region_in_landscan_pop_res <- foster::matchResolution(pol_raw_0.01_region, pop_raw_landscan_region)

# creating a life years lost to WHO layer for India
pol_values_region <- values(pol_raw_0.01_region)

# creating a raster brick using the population and pollution data for India.
region_raster_brick <- pop_raw_landscan_region %>% 
  addLayer(pol_0.01_region_in_landscan_pop_res) %>%
  addLayer(pol_0.01_region_in_landscan_pop_res) %>%
  addLayer(pol_0.01_region_in_landscan_pop_res)

# setting the names of the newly created placheoldes
names(region_raster_brick) <- c("population_2021", "pollution_2021", "lyl_who_standard", "lyl_nat_standard")

# generating values for layers containing lyl numbers relative to WHO standard
region_pollution_numbers <- values(region_raster_brick$pollution_2021)
region_lyl_numbers_who <- (region_pollution_numbers - who_pm2.5_standard)*aqli_lyl_constant
region_lyl_numbers_who <- ifelse(region_lyl_numbers_who < 0, 0, region_lyl_numbers_who)

# generating values for layers containing lyl numbes relative to the National standard
region_lyl_numbers_nat_standard <- (region_pollution_numbers - region_pm2.5_standard) * aqli_lyl_constant
region_lyl_numbers_nat_standard <- ifelse(region_lyl_numbers_nat_standard < 0, 0, region_lyl_numbers_nat_standard)

# updating the lyl layers with the above values
values(region_raster_brick$lyl_who_standard) <- region_lyl_numbers_who
values(region_raster_brick$lyl_nat_standard) <- region_lyl_numbers_nat_standard

# set the same crs for india pollution brick
crs(region_raster_brick) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

# Now match each population/pollution point to a colormap polygon. To do this, convert
# polygons to raster of same resolution as population raster, with value of each cell equal
# to objectid of polygon that covers its center.
# Fasterize is an ultra-fast version of the rasterize function.
print("Beginning to rasterize colormap shapefile")
polygon_cells <- fasterize(colormap_region, pol_0.01_region_in_landscan_pop_res, field = "objectid", fun = "last")
writeRaster(polygon_cells,
	filename = "./qgis_experimentation/colormap_india_rasterized.tif",
	format = "GTiff", overwrite = TRUE)

region_raster_brick <- region_raster_brick %>% addLayer(polygon_cells)

names(region_raster_brick)[length(names(region_raster_brick))] <- "colormap_objectid"

# convert to dataframe
region_raster_brick_df <- raster::as.data.frame(region_raster_brick)

# join with colormap (sans geometry)
region_raster_brick_df_joined_colormap <- region_raster_brick_df %>%
  left_join(colormap_region %>% st_drop_geometry(), by = c("colormap_objectid" = "objectid"))

# group by object id (which is gadm level 2) and create a population weighted average of pollution 

region_raster_brick_df_joined_colormap_summary <- region_raster_brick_df_joined_colormap %>%
  dplyr::group_by(colormap_objectid) %>%
  dplyr::mutate(pop_weights_gadm2  = population_2021/sum(population_2021, na.rm = TRUE),
                pm2021_pop_weighted = pollution_2021*pop_weights_gadm2) %>%
  dplyr::summarise(avg_pm2.5_2021 = sum(pm2021_pop_weighted, na.rm = TRUE)) %>%
  rename(objectid = colormap_objectid)

# join with colormap (with geometry)
region_raster_brick_df_joined_colormap_summary_geom <- region_raster_brick_df_joined_colormap_summary %>%
  left_join(colormap_region, by = "objectid")

# add lyl relative to WHO and National Standard column
region_raster_brick_df_joined_colormap_summary_geom <- region_raster_brick_df_joined_colormap_summary_geom %>%
  mutate(lyl_rel_who_2021 = (avg_pm2.5_2021 - who_pm2.5_standard) * aqli_lyl_constant, 
         lyl_rel_who_2021 = ifelse(lyl_rel_who_2021 < 0, 0, lyl_rel_who_2021), 
         lyl_rel_nat_stan_2021  = (avg_pm2.5_2021 - india_pm2.5_standard) * aqli_lyl_constant, 
         lyl_rel_nat_stan_2021 = ifelse(lyl_rel_nat_stan_2021 < 0, 0, lyl_rel_nat_stan_2021)) %>%
  select(objectid:NAME_2, lyl_rel_who_2021, lyl_rel_nat_stan_2021, everything()) 
  
region_raster_brick_df_joined_colormap_summary_geom <- st_as_sf(region_raster_brick_df_joined_colormap_summary_geom)
  
foo_plt <- region_raster_brick_df_joined_colormap_summary_geom %>%
  ggplot() +
  geom_sf(mapping = aes(fill = lyl_rel_who_2021)) + 
  scale_fill_viridis_b(option = "rocket", direction = -1) + 
  ggthemes::theme_map() +
   labs(title = "Cameroon: Life years lost relative to WHO guideline", 
       subtitle = "using AQLI 2021 0.01x0.01 res pollution data")

foo <- region_raster_brick_df_joined_colormap_summary_geom %>%
  ggplot() +
  geom_sf(mapping = aes(fill = lyl_rel_who_2021)) + 
  scale_fill_viridis_b(breaks = c(0, 0.1, 0.5, 1, 2, 3, 4, 5, 6)) +
  labs(title = "Cameroon: Life years lost relative to WHO guideline", 
       subtitle = "using AQLI 2021 0.01x0.01 res pollution data")

```






# Using the new workflow, generate gadm level 2 population weighted pollution and life years lost numbers (WHO and National Standard) for a given year's Global data. Standalone, uses its own data files, not the data files from the second chunk up top.

```{r}

# start time

start_time <- Sys.time()

#> paths----------------------------------------

# pollution
pol_data_location <-"./ar.2023.update.using.2021.pol.data/data/input/pollution/0.01x0.01/GWRPM25-NoDust-NoSeaSalt_0.01_0.01/GWRPM25-NoDust-NoSeaSalt/Annual/"



# population
pop_data_location <- "./ar.2023.update.using.2021.pol.data/data/input/population/"
pop_data_file_name <- "landscan-global-2021.tif"



# shapefiles
shp_files_location <- "./ar.2023.update.using.2021.pol.data/data/intermediate/1_population_and_colormap/1_shapefile_aggregate/"

colormap_location <- "colormap/colormap.shp"

hovermap_location <- "hover/hover.shp"

# ssd aqli folder location
ssd_location <- "D:/aqli"



#-------------------------------------------------


# benchmarking
threshold_0 <- Sys.time() #r1: 0 seconds, r2: 0 seconds

# population raw data
population_dataset <- raster::raster(str_c(pop_data_location, pop_data_file_name, sep = ""))

# naming the raw global landscan population data and setting its crs to be the same as the pollution data
crs(population_dataset) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
names(population_dataset) <- "population"


#--- no longer need to crop, as this can be reused, so I wrote it as a tif, and then will simply read it
#- crop population dataset to the pollution dataset
# pop_raw_landscan_crop_pol <- raster::crop(population_dataset, pollution_dataset)

#- write the cropped population dataset
# pop_raw_landscan_crop_pol %>%
#   raster::writeRaster(filename = "./experimentation/pop_raw_landscan_crop_pol.tif", 
#                       format = "GTiff", overwrite = TRUE)
#---

# reading in the pre-cropped population raster, which remains the same for all pollution datasets
pop_raw_landscan_crop_pol <- raster::raster("./experimentation/pop_raw_landscan_crop_pol.tif")


# load latest colormap shapefile for (last complete updated: November, 2022)
colormap <- st_read(str_c(shp_files_location, colormap_location, sep = ""))

# load the latest hover shapefile (last complete update: November, 2022)
hovermap <- st_read(str_c(shp_files_location, hovermap_location, sep = "")) %>%
  rename(objectid_hover = objectid)


# read color hover crosswalk
gadm_hover_color_crosswalk <- readxl::read_excel(str_c(shp_files_location, "crosswalks/gadm_hover_color/gadm_hover_color_crosswalk.xlsx", sep = ""))


#-- this remains same for all pollution datasets, hence writing it, and will then simply read it
# polygon_cells <- fasterize(colormap, pol_0.01_region_in_landscan_pop_res, field = "objectid", fun = "last")
# writeRaster(polygon_cells,
# 	filename = "./experimentation/colormap_rasterized.tif",
# 	format = "GTiff", overwrite = TRUE)
#---

polygon_cells <- raster::raster("./experimentation/colormap_rasterized.tif")


# benchmarking
threshold_1 <- Sys.time() # r1 (t0 to t1:18 seconds), r2 (t0 to t1: 7.04 seconds)


#> reading pollution data, one year at a time and then will concatenate all results-----------------------

# pollution datasets list
pol_data_list <- list.files(pol_data_location)

for (i in 4:length(pol_data_list)){
  
  print(str_c("Iteration #", i, " begins"))
  
  if(i == 6){
    break
  }
  
  # pollution file name given the current iteration
  cur_pol_file_name <- pol_data_list[i]
  
  # cur pollution file year
  cur_pol_file_year <- str_extract(str_extract(cur_pol_file_name, "(\\d+)-(\\d+)"), "....")
  
  # read in the pollution raster for a given year
  pollution_dataset <- raster::raster(str_c(pol_data_location, cur_pol_file_name, sep = ""))
  
  # naming the raw global pollution data and setting its crs
crs(pollution_dataset) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
names(pollution_dataset) <- "pm2.5_pollution"


# benchmarking
threshold_2 <- Sys.time() # r1 (t1 to t2: 1.56 minutes), r2 (t1 to t2: 0.07 seconds)

# matching the resolution of the cropped population and pollution datasets
pol_0.01_region_in_landscan_pop_res <- foster::matchResolution(pollution_dataset, pop_raw_landscan_crop_pol)

# benchmarking
threshold_3 <- Sys.time() # r1 (t2 to t3: 12.65 minutes), r2 (t2 to t3: 6.15 minutes)

print("stacking all layers in a raster brick")

# creating a raster brick using the population and pollution data for India.
region_raster_brick <- pop_raw_landscan_crop_pol %>% 
  addLayer(pol_0.01_region_in_landscan_pop_res) 

# setting the names of the newly created placheolders
names(region_raster_brick) <- c("population", "pm2.5_pollution")

# set the same crs for india pollution brick
crs(region_raster_brick) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

print("Population and pollution layers matched")

# benchmarking
threshold_4 <- Sys.time() # r1 (t3 to t4: 0.63 seconds), r2 (t3 to t4: 0.27 seconds)

# Now match each population/pollution point to a colormap polygon. To do this, convert
# polygons to raster of same resolution as population raster, with value of each cell equal
# to objectid of polygon that covers its center.
# Fasterize is an ultra-fast version of the rasterize function.

# add rasterized colormap to the raster brick
region_raster_brick <- region_raster_brick %>% addLayer(polygon_cells)

print("added rasterized colormap layer to the brick")

names(region_raster_brick)[length(names(region_raster_brick))] <- "colormap_objectid"

# benchmarking
threshold_5 <- Sys.time() # r1 (t4 to t5: 15.47 seconds), r2 (t4 to t5: 0.36 seconds)

# convert to dataframe
region_raster_brick_df <- raster::as.data.frame(region_raster_brick)

print("raster brick converted to data frame")

# write rasterized dataframe to ssd, in arrow data format
region_raster_brick_df %>% arrow::write_dataset(str_c(ssd_location, cur_pol_file_year))

# benchmarking
threshold_6 <- Sys.time() # r1 (t5 to t6: 5.09 minutes), r2 (t5 to t6: 4.96 minutes)

#-- (Update: no longer needed as we directly coerce region_raster_brick_df to an arrow table). Will only need to write this when implementing high res layer.
#- write region_raster_brick_df to a csv
#--

pollution_data_0.01_light <- arrow::as_arrow_table(region_raster_brick_df)

# benchmarking
threshold_7 <- Sys.time() # r1 (t6 to t7: 4.89 minutes), r2 (t6 to t7: 21.03 seconds)

print("rasterized dataframe coerced to an arrow table")

#-- read raster data using arrow (no longer needed as we already coerced region_raster_brick_df to an arrow table)
# pollution_data_0.01_light <- arrow::open_dataset("./experimentation/pollution_data_0.01_2021.csv", format = "csv")
#-- 

# benchmarking
threshold_8 <- Sys.time() # r1 (t7 to t8: 35.41 seconds), r2 (t7 to t8: 0.09 seconds)

# generating district level results
pollution_district_wise <- pollution_data_0.01_light %>%
  group_by(colormap_objectid) %>%
  collect() %>%
  mutate(pop_weights = population/sum(population, na.rm = TRUE), 
         pollution_pop_weighted = pop_weights*pm2.5_pollution) %>%
  summarise(total_population = sum(population, na.rm = TRUE), 
            avg_pm2.5_pollution = sum(pollution_pop_weighted, na.rm = TRUE), 
            lyl_rel_who = round((avg_pm2.5_pollution - who_pm2.5_standard)*aqli_lyl_constant, 2), 
            lyl_rel_who = ifelse(lyl_rel_who < 0, 0, lyl_rel_who)) %>%
  rename(objectid = colormap_objectid)

# benchmarking
threshold_9 <- Sys.time() # r1 (t8 to t9: 6.89 minutes), r2 (t8 to t9: 4.53 minutes)

# joining the pollution district wise data to colormap, to get district, state, country names and the geometry column

pollution_district_wise_matched_colormap <- pollution_district_wise %>%
  left_join(colormap, by = c("objectid")) %>%
  select(objectid, iso_alpha3, NAME_0, NAME_1, NAME_2, total_population, avg_pm2.5_pollution, lyl_rel_who, geometry) %>%
rename(objectid_color = objectid) %>%
  st_as_sf()
  
#> sanity checks
sum(is.na(pollution_district_wise_matched_colormap$iso_alpha3)) #1
sum(is.na(pollution_district_wise_matched_colormap$objectid_color)) #1, objectid: 48060
sum(is.na(pollution_district_wise_matched_colormap$NAME_0))
sum(is.na(pollution_district_wise_matched_colormap$NAME_1))
sum(is.na(pollution_district_wise_matched_colormap$NAME_2))
sum(is.na(pollution_district_wise_matched_colormap$total_population))
sum(is.na(pollution_district_wise_matched_colormap$avg_pm2.5_pollution))
sum(is.na(pollution_district_wise_matched_colormap$lyl_rel_who))
sum(is.na(pollution_district_wise_matched_colormap$geometry))

# gadm colormap object ids that are present in the colormap file, but not in the collapsed gadm level 2 file that we
# got from collapsing pollution_data_0.01_light. Need to match these separately.
colormap$objectid[!(colormap$objectid %in% pollution_district_wise_matched_colormap$objectid_color)] # 152 in total
  
print("Starting to collapse district level file to hover file")

# pollution district wise, collapse to hover level
pollution_district_wise_join_ch_crosswalk <- pollution_district_wise_matched_colormap %>%
  left_join(gadm_hover_color_crosswalk, by = c("objectid_color")) %>%
  select(objectid_color, objectid_hover, iso_alpha3, NAME_0, NAME_1, NAME_2, everything())

# sanity check (number of hover ids not present in the collapsed district level file. # 40. To be taken care of 
# separately
length(unique(gadm_hover_color_crosswalk$objectid_hover)) - length(unique(pollution_district_wise_join_ch_crosswalk$objectid_hover))

# A geometry stripped off version of "pollution_district_wise_join_ch_crosswalk"
pollution_district_wise_join_ch_crosswalk_non_geom <- pollution_district_wise_join_ch_crosswalk %>%
  st_drop_geometry()

# collapse (i.e. summarise) to hover level from the district level
pollution_hover_level_non_geom <- pollution_district_wise_join_ch_crosswalk_non_geom %>%
  group_by(objectid_hover) %>%
   mutate(pop_weights = total_population/sum(total_population, na.rm = TRUE), 
         pollution_pop_weighted = pop_weights*avg_pm2.5_pollution) %>%
  summarise(total_population = sum(total_population, na.rm = TRUE), 
            avg_pm2.5_pollution = sum(pollution_pop_weighted, na.rm = TRUE), 
            lyl_rel_who = round((avg_pm2.5_pollution - who_pm2.5_standard)*aqli_lyl_constant, 2), 
            lyl_rel_who = ifelse(lyl_rel_who < 0, 0, lyl_rel_who)) 

# adding in the geometry column to the summarized "pollution_hover_file", using the "hovermap" shapefile, outputted by "1_shapefile_aggregate.R"

pollution_hover_level_with_geom <- pollution_hover_level_non_geom %>%
  left_join(hovermap, by = c("objectid_hover")) %>%
  st_as_sf()

# benchmarking
threshold_10 <- Sys.time() 


#> sanity checks in QGIS (optional)
# 
# # collapsed color file
# pollution_district_wise_matched_colormap %>% st_write("./experimentation/qgis/pollution_district_wise_matched_colormap_Dec102022.shp")  
# 
# # collapsed hover file
# pollution_hover_level %>%
#   st_write("./experimentation/qgis/pollution_hover_level_Dec102022.shp")

print(str_c("Iteration #", i, " ends"))
 
}

end_time <- Sys.time()
time_diff <- end_time - start_time
print(str_c("Time difference: ", time_diff, " minutes"))
  





```
